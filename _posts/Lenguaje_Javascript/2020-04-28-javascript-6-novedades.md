---

author: rosepac
bootstrap: true
comments: false
tags:
- Javascript
categories:
- Lenguajes Programaci√≥n
thumbnail: /assets/img/blog/javascript-6.webp
feature-img: /assets/img/blog/javascript-6.webp
title: 'üöÄ ‚ñ∑ Introducci√≥n a las nuevas caracter√≠sticas de Javascript 6'
description: >-
  JavaScript ES6 trae una nueva sintaxis y nuevas caracter√≠sticas incre√≠bles para hacer que su c√≥digo sea m√°s moderno y m√°s legible. 
excerpt: >-
  JavaScript ES6 trae una nueva sintaxis y nuevas caracter√≠sticas incre√≠bles para hacer que su c√≥digo sea m√°s moderno y m√°s legible. 
canonical_URL: https://ciberninjas.com/javascript-6/
permalink: /javascript-6/
date: 2020-04-28 00:32:32
last_modified_at: 
published: true

---

![Las mejores novedades de Javascript 6](/assets/img/blog/javascript-6.webp "Las mejores novedades de Javascript 6")

JavaScript ES6 trae una nueva sintaxis y nuevas caracter√≠sticas incre√≠bles para hacer que su c√≥digo sea m√°s moderno y m√°s legible. Le permite escribir menos c√≥digo y hacer m√°s. ES6 nos presenta muchas caracter√≠sticas excelentes.

En este art√≠culo, exploraremos cinco de estas caracter√≠sticas de ES6 y consideraremos c√≥mo podemos utilizarlas para mejorar nuestro c√≥digo JavaScript. Estas son las caracter√≠sticas de inter√©s:

> üî• Seguro tambi√©n te interesa: [mejores libros de programaci√≥n](/programar/) >> [programas para desarrolladores](/mejores-sistemas-operativos-para-hackear/) >> [mejores lenguajes de programaci√≥n](/15-mejores-lenguajes-programacion/) >> [port√°tiles para programadores]() >> [mejores auriculares para programadores](/auriculares-dise%C3%B1o/) >> [ratones verticales para trabajar](/teclados-ratones-dise%C3%B1o/) >> [componentes de PC para programadores](/ordenadores-componentes/) >> [mejores regalos 1 - üì¶](/black-friday-amazon/)
{: .notice--danger}

## **1. Literales de plantilla**

En ES6, se introdujeron literales de plantilla para abordar algunos desaf√≠os asociados con el formato y la representaci√≥n de cadenas. Con los literales de plantilla, puede crear cadenas de varias l√≠neas con facilidad. Tambi√©n permite realizar sustituciones mejoradas de cadenas y un formato adecuado de cadenas aparentemente peligrosas, como las cadenas que se incrustar√°n en HTML.

Antes de ES6, las cadenas est√°n delimitadas por un par de *comillas simples* ( `‚Äòstring‚Äô`) o un par de *comillas dobles* ( `‚Äústring‚Äù`). En ES6, las cadenas tambi√©n se pueden delimitar mediante un par de *ticks* de *retroceso* ( `string`). Tales cadenas se llaman **literales de plantilla** .

Al igual que con los delimitadores de comillas simples y dobles, las marcas de retroceso tambi√©n se pueden escapar en literales de plantilla si la cadena contiene un car√°cter de marca de retroceso. Para escapar de un car√°cter de retroceso en una plantilla literal, se debe colocar una barra diagonal () antes del car√°cter de retroceso. Sin embargo, tenga en cuenta que las comillas simples y dobles no necesitan escaparse en literales de plantilla.

Aqu√≠ hay un ejemplo simple:

```
const greeting = `Good morning!`;
const shortcut = ``cmd` + `shift` + `G``;

console.log(greeting); // "Good morning!"
console.log(shortcut); // "`cmd` + `shift` + `G`"
```

El uso de literales de plantilla de esta manera no es muy diferente del uso de cadenas de JavaScript regulares delimitadas por comillas. Comenzamos a obtener las ventajas reales cuando se trata de *cadenas multil√≠nea* , *sustituciones de cadenas* y *plantillas etiquetadas* .

### Cuerdas multil√≠nea

Antes de ES6, las cadenas en JavaScript se limitaban a una sola l√≠nea. Sin embargo, terminar una l√≠nea con una barra diagonal inversa () antes de comenzar una nueva l√≠nea hizo posible crear cadenas de varias l√≠neas aparentes aunque las nuevas l√≠neas no se muestren en la cadena:



```
const message = "Hello Glad, 
Your meeting is scheduled for noon today.";

console.log(message);
// Hello Glad, Your meeting is scheduled for noon today.
```

Si desea generar una nueva l√≠nea en la cadena, deber√° usar la secuencia de escape de nueva l√≠nea ( `n`) antes de la nueva l√≠nea:

```
const message = "Hello Glad,n
Your meeting is scheduled for noon today.";

console.log(message);
// Hello Glad,
// Your meeting is scheduled for noon today.
```

> Con los literales de plantilla ES6, la cadena se genera con el formato intacto.

Todas las l√≠neas nuevas y espacios en blanco en la cadena se conservan, lo que hace que las cadenas de l√≠neas m√∫ltiples sean f√°ciles de crear sin ninguna sintaxis adicional. Sin embargo, dado que se conservan los espacios en blanco, se debe tener cuidado al sangrar la cadena.

Considere este ejemplo:

```
const html = (`
<html>
  <body>
    Template literals are super cool.
  </body>
</html>
`).trim();

console.log(html);
// <html>
//   <body>
//     Template literals are super cool.
//   </body>
// </html>
```

Observe que las l√≠neas nuevas y las hendiduras se conservan en la cadena. El `trim()`m√©todo tambi√©n se usa para eliminar las l√≠neas nuevas y los espacios en blanco al comienzo y al final de la cadena html.

### Sustituci√≥n de cadenas

Los literales de plantilla tambi√©n hacen que las sustituciones de cadenas sean divertidas. Antes de ES6, se confiaba mucho en la *concatenaci√≥n de cadenas* para crear cadenas din√°micas.

Aqu√≠ hay un ejemplo simple:

```
const price = 24.99;

console.log("The item costs $" + price + " on the online store.");
// The item costs $24.99 on the online store.
```

Usando literales de plantilla ES6, la sustituci√≥n se puede hacer de la siguiente manera:

```
const price = 24.99;

console.log(`The item costs ${price} on the online store.`);
// The item costs $24.99 on the online store.
```

Una sustituci√≥n de cadena est√° delimitada por una apertura `${`y un cierre `}`y puede contener cualquier expresi√≥n v√°lida de JavaScript en el medio.

En el ejemplo anterior, sustituimos el valor de una variable simple en el literal de la plantilla. Digamos que queremos agregar un 10% de descuento al precio de todos los art√≠culos en la tienda.

As√≠ es como se ve:

```
const price = 24.99;
const discount = 10;

console.log(`The item costs ${(price * (100 - discount) / 100).toFixed(2)} on the online store.`);
// The item costs $22.49 on the online store.
```

Aqu√≠ sustituimos el valor de una expresi√≥n de JavaScript que calcula el precio con descuento.

> Los literales de plantilla son expresiones de JavaScript en s√≠ mismas y, como tales, pueden anidarse dentro de otros literales de plantilla.

### Etiquetas de plantilla

Con las plantillas etiquetadas, incluso tiene m√°s control sobre las sustituciones y la transformaci√≥n del literal de la plantilla. **Una \*etiqueta de plantilla\* es simplemente una funci√≥n que define c√≥mo se debe transformar un literal de plantilla** .

Una funci√≥n de etiqueta de plantilla puede aceptar m√∫ltiples argumentos. El primer argumento es una matriz que contiene todas las cadenas literales en la plantilla literal. Los argumentos restantes corresponden a las sustituciones en la plantilla literal. Por lo tanto, el segundo argumento corresponde con la primera sustituci√≥n, el tercer argumento corresponde con la segunda sustituci√≥n y as√≠ sucesivamente.

Aqu√≠ hay una ilustraci√≥n simple. Dado el siguiente literal de plantilla:

```
`The price of ${quantity} units of the item on the online store is $${quantity * price}.`
```

El primer argumento pasado a una etiqueta de plantilla para este literal de plantilla ser√° la matriz de cadenas literales que es la siguiente:

```
[
  'The price of ',
  ' units of the item on the online store is /figure>,
  '.'
]

```

El segundo argumento ser√° el valor de `quantity`y el tercer argumento ser√° el valor de `(quantity * price)`.

Avancemos y `pricing`creemos una etiqueta de plantilla llamada que podamos usar para transformar el resumen de precios. Asegurar√° que los valores de los precios se redondeen a 2 decimales. Tambi√©n asegurar√° que el `$`s√≠mbolo de moneda antes de convertir cualquier precio `USD`.

Aqu√≠ est√° la funci√≥n:

```
function pricing(literals, ...replacements) {
  // Initialize the final string
  let finalString = '';

  for (let i = 0; i < replacements.length; i++) {
    // Get the current literal and replacement
    const literal = literals[i];
    const replacement = replacements[i];

    // Trim trailing whitespaces from the current literal
    const trimmed = literal.trimRight();
    const length = trimmed.length;

    // Check if current replacement is a number
    const isNumber = typeof replacement === 'number';

    // Check if current literal string ends with $
    const isPrice = /$/.test(trimmed);

    // Check if number is followed by literal that ends with $
    // and use the desired formatting
    finalString += (isNumber && isPrice)
      ? `${trimmed.substr(0, length - 1).trimRight()} USD ${replacement.toFixed(2)}`
      : `${literal}${replacement}`;
  }

  // Attach the last literal to the final string
  return finalString + literals[literals.length - 1];
}

```

Notar√≠a en este fragmento de c√≥digo que usamos un par√°metro de descanso llamado `replacements`para capturar todas las sustituciones en el literal de la plantilla. *Aprenderemos m√°s sobre los par√°metros de descanso en la siguiente secci√≥n* .

Ahora que hemos creado una etiqueta de plantilla, usarla es la parte f√°cil.

> Para usar una etiqueta de plantilla, simplemente adjunte el nombre de la etiqueta de plantilla justo antes del primer delimitador de retroceso (`` `) del literal de plantilla.

Aqu√≠ hay un ejemplo usando la `pricing`etiqueta de plantilla que acabamos de crear:

```
const price = 24.99;
const discount = 10;
const quantity = 4;

const totalPrice = quantity * price * (100 - discount) / 100;

// WITHOUT TEMPLATE TAG
console.log(`The price of ${quantity} units of the item on the online store is ${totalPrice}.`);
// The price of 4 units of the item on the online store is $89.964.

// WITH TEMPLATE TAG (pricing)
console.log(pricing`The price of ${quantity} units of the item on the online store is ${totalPrice}.`);
// The price of 4 units of the item on the online store is USD 89.96.

```

## **2. Par√°metros predeterminados y de descanso**

Las funciones en JavaScript son objetos muy importantes. Es muy posible que haya encontrado la declaraci√≥n:

> "Las funciones son ciudadanos de primera clase".

Esto es cierto sobre las funciones de JavaScript porque puede pasarlas en su programa como lo har√≠a con cualquier otro valor regular.

Sin embargo, las funciones de JavaScript no han tenido ninguna mejora considerable de sintaxis hasta ES6. Con ES6, ahora tenemos algunas mejoras de sintaxis como *par√°metros predeterminados* , *par√°metros de descanso* , *funciones de flecha* , etc.

### **Par√°metros por defecto**

Antes de ES6, b√°sicamente no hab√≠a sintaxis para establecer los valores predeterminados para los par√°metros de la funci√≥n. Sin embargo, hubo algunos trucos para establecer valores de reserva para par√°metros de funci√≥n cuando no se pasan valores en el tiempo de invocaci√≥n. Aqu√≠ hay un ejemplo simple:

```
// METHOD 1: Short-circuiting
// Using the logical OR (||) operator
function convertToBase(number, base) {
  number = parseInt(number) || 0;
  base = parseInt(base) || 10;

  return number.toString(base);
}

// METHOD 2: Ternary (?:) operator
// With additional type check (safer option)
function convertToBase(number, base) {
  number = (typeof number !== "undefined") ? parseInt(number) : 0;
  base = (typeof base !== "undefined") ? parseInt(base) : 10;

  return number.toString(base);
}

```

En este fragmento, hemos podido establecer valores predeterminados para los par√°metros de la funci√≥n. Por lo tanto, estos par√°metros se comportan como si fueran opcionales, ya que los valores de reserva se utilizan cuando no se pasan los par√°metros.

En ES6, puede inicializar el par√°metro de funci√≥n con un valor predeterminado que se usar√° cuando el par√°metro no se pase o se pase `undefined`. As√≠ es como podemos reescribir nuestra `convertToBase()`funci√≥n anterior con par√°metros predeterminados:

```
function convertToBase(number = 0, base = 10) {
  return parseInt(number).toString(parseInt(base));
}

```

Los par√°metros de funciones con nombre en ES6 tienen el mismo comportamiento que las `let`declaraciones. Los valores predeterminados en ES6 no se limitan solo a valores literales o primitivos.

> Cualquier expresi√≥n de JavaScript tambi√©n se puede usar como valores predeterminados para par√°metros de funci√≥n.

Aqu√≠ hay un ejemplo:

```
function getDefaultNumberBase() {
  return 10;
}

function convertToBase(number = 0, base = getDefaultNumberBase()) {
  return parseInt(number).toString(parseInt(base));
}

```

Aqu√≠, estamos utilizando el valor de retorno de `getDefaultNumberBase()`como el valor predeterminado para el `base`par√°metro. Incluso puede usar el valor de un par√°metro anterior al establecer el valor predeterminado para otro par√°metro. Aqu√≠ hay un ejemplo:

```
function cropImage(width, height = width) {
// ...implementation
}

```

En este fragmento, el `height`par√°metro se establecer√° en el valor del `width`par√°metro cada vez que no se pasa o no `undefined`.

Aunque puede usar valores de par√°metros anteriores al establecer valores predeterminados, no puede usar variables declaradas dentro del cuerpo de la funci√≥n. Esto se debe a que los par√°metros predeterminados tienen su propio alcance que est√° separado del alcance del cuerpo de la funci√≥n.

### **Par√°metros de descanso**

El `arguments`objeto es el medio √∫ltimo para capturar todos los argumentos pasados a una funci√≥n en la invocaci√≥n. Esto hace posible crear funciones sobrecargadas que pueden aceptar un n√∫mero variable de argumentos.

> Sin embargo, el `arguments`objeto, aunque es similar a una matriz, debe convertirse en una matriz real antes de que ciertas operaciones de la matriz puedan llevarse a cabo en √©l.

Aqu√≠ hay un ejemplo simple:

```
function sum() {
  // Convert arguments to array
  var args = Array.prototype.slice.call(arguments);

  // Compute sum using array reduce()
  return args.reduce(function(a, b) { return a + Number(b) }, 0);
}

```

Esta funci√≥n calcula la suma de cualquier n√∫mero de argumentos que se le hayan pasado. Si el argumento no es un `number`, intenta convertirlo a un n√∫mero utilizando la `Number()`funci√≥n global. Regresa `0`si no se pasa ning√∫n argumento. Observe que el `arguments`objeto se convirti√≥ primero en una matriz y se asign√≥ a la `args`variable para usar el `reduce()`m√©todo.

En ES6, se introdujeron los *par√°metros de descanso* . Un **par√°metro de reposo** **es simplemente un** **par√°metro de funci√≥n con nombre precedido por tres puntos** ( `...`). Al par√°metro rest se le asigna una matriz que contiene los argumentos restantes pasados a una funci√≥n. Aqu√≠ es c√≥mo podemos reescribir nuestra `sum()`funci√≥n anterior usando un par√°metro rest:

```
function sum(...args) {
  // Compute sum using array reduce()
  return args.reduce((a, b) => a + Number(b), 0);
}
```

**Hay algunas cosas que vale la pena se√±alar con respecto al uso de par√°metros de descanso.**

1. Solo puede tener un par√°metro de descanso para una funci√≥n.
2. El par√°metro rest, cuando est√° presente, debe ser el √∫ltimo par√°metro.
3. Un par√°metro de reposo no es lo mismo que el `arguments`objeto. Solo captura los argumentos restantes despu√©s de los otros par√°metros nombrados, mientras que el `arguments`objeto captura todos los argumentos pasados a la funci√≥n independientemente.
4. No se puede usar un par√°metro rest en un establecedor literal de objetos.

### **Operador extendido**

Digamos que tenemos una matriz que contiene los puntajes de los estudiantes en una clase y queremos calcular el puntaje promedio de los estudiantes. B√°sicamente, primero calcularemos la suma de los puntajes y luego dividiremos la suma por el n√∫mero de puntajes.

Podemos usar la `sum()`funci√≥n que creamos en la secci√≥n anterior para calcular la suma de los puntajes. Sin embargo, el problema es que tenemos una serie de puntajes y la suma espera n√∫meros como argumentos.

Antes de ES6, el `Function.prototype.apply()`m√©todo se puede usar para manejar casos como este. Este m√©todo toma una matriz como segundo argumento que representa los argumentos con los que se debe invocar la funci√≥n.

Aqu√≠ hay un ejemplo:

```
const scores = [42, 68, 49, 83, 72, 65, 77, 74, 86, 51, 69, 47, 53, 58, 51];
const totalScore = sum.apply(null, scores);
const averageScore = totalScore / scores.length;

console.log(totalScore); // 945
console.log(averageScore); // 63

```

En ES6, se introdujo un nuevo operador conocido como el *operador spread* ( `...`). Est√° estrechamente relacionado con los par√°metros de reposo y es muy √∫til para tratar con matrices y otros *iterables* . Con el operador de propagaci√≥n podemos calcular lo `totalScore`siguiente:

```
const totalScore = sum(...scores);

```

> Por lo tanto, para la mayor√≠a de los casos de uso, el operador de propagaci√≥n es un buen reemplazo para el `Function.prototype.apply()`m√©todo.

## **3. Funciones de flecha**

Otra mejora de sintaxis muy importante en ES6 es la introducci√≥n de *funciones* de *flecha* . Las funciones de flecha hacen uso de una sintaxis completamente nueva y ofrecen un par de grandes ventajas cuando se utilizan de la manera m√°s adecuada.

La sintaxis para las funciones de flecha omite la `function`palabra clave. Adem√°s, los par√°metros de la funci√≥n se separan del cuerpo de la funci√≥n utilizando una *flecha* ( `=>`), de ah√≠ el nombre de *las funciones de flecha* .

Aunque las funciones de flecha son m√°s compactas y m√°s cortas que las funciones regulares, son significativamente diferentes de las funciones regulares en algunos aspectos que definen c√≥mo se pueden usar:

1. Las funciones de flecha no pueden usarse como constructores y no tienen prototipo. Por lo tanto, usar la `new`palabra clave con una funci√≥n de flecha generalmente dar√° como resultado un error.
2. Las funciones de flecha no tienen `arguments`objeto, por lo tanto, los par√°metros con nombre y los par√°metros de reposo deben usarse para argumentos de funci√≥n. Los par√°metros con nombre duplicados tampoco est√°n permitidos.
3. El `this`enlace dentro de una funci√≥n de flecha no se puede modificar, y siempre apunta a la funci√≥n principal m√°s cercana que no sea una flecha.

### **Sintaxis de la funci√≥n de flecha**

Las funciones de flecha pueden verse ligeramente diferentes seg√∫n lo que desee lograr.

Echemos un vistazo a algunas formas:

**Sin par√°metros**

Si no hay par√°metros para la funci√≥n de flecha, se `()`debe usar un par de par√©ntesis vac√≠o ( ) antes de la flecha ( `=>`) como se muestra en el siguiente fragmento.

```
// USING REGULAR FUNCTION
const getTimestamp = function() {
  return +new Date;
}

// USING ARROW FUNCTION
const getTimestamp = () => {
  return +new Date;
}

```

Para funciones de flecha muy simples como esta que solo devuelven el valor de una expresi√≥n de JavaScript, se pueden omitir la `return`palabra clave y el par de llaves ( `{}`) que rodean el cuerpo de la funci√≥n.

Por lo tanto, la funci√≥n de flecha se puede reescribir as√≠:

```
const getTimestamp = () => +new Date;

```

Sin embargo, si se devuelve un literal de objeto de la funci√≥n de flecha, debe envolverse con un par de par√©ntesis ( `()`), de lo contrario, el motor de JavaScript ve que las llaves ( `{}`) del literal de objeto contienen el cuerpo de la funci√≥n que dar√° como resultado la sintaxis error. Aqu√≠ hay un ejemplo:

```
// Returned object literal wrapped in parentheses
const getProfile = () => ({
  name: 'Glad Chinda',
  gender: 'Male',
  birthday: 'August 15'
});

```

**Con par√°metros**

Para las funciones de flecha que toman solo un par√°metro con nombre, el par de par√©ntesis que rodea la lista de par√°metros se puede omitir como se muestra en el siguiente fragmento:

```
// Pair of parentheses is omitted
const computeSquare = num => num * num;

```

Sin embargo, hay situaciones en las que no se puede omitir el par√©ntesis que rodea la lista de par√°metros. Estas son algunas de esas situaciones:

1. Cuando hay m√°s de un par√°metro con nombre

```
// Pair of parentheses cannot be omitted
const addNumbers = (numA, numB) => numA + numB;

```

2. Cuando hay un par√°metro predeterminado, incluso si es el √∫nico par√°metro

```
// The traditional function body wrapped in curly braces
// is used here to aid readability.
// Pair of parentheses cannot be omitted

const factorial = (n = 1) => {
  return (n <= 1) ? 1 : n * factorial(n - 1);
}

```

3. Cuando hay un par√°metro de reposo, incluso si es el √∫nico par√°metro

```
// Pair of parentheses cannot be omitted
const range = (...numbers) => Math.max(...numbers) - Math.min(...numbers);

```

4. Cuando hay un par√°metro desestructurado, incluso si es el √∫nico par√°metro

```
// Pair of parentheses cannot be omitted
const extractName = ({ name = null }) => name;

console.log(extractName({
  name: 'Glad Chinda',
  role: 'author'
})); // "Glad Chinda"

```

**Cuerpo de la funci√≥n tradicional**

Como se mostr√≥ anteriormente para funciones de flecha muy simples que solo devuelven el valor de una expresi√≥n de JavaScript, se pueden omitir la `return`palabra clave y el par de llaves ( `{}`) que rodean el cuerpo de la funci√≥n. Sin embargo, a√∫n puede usar el cuerpo de la funci√≥n tradicional si lo desea y especialmente cuando la funci√≥n tiene varias declaraciones.

```
const snakeCase = value => {
  const regex = /[A-Z][^A-Z]+/g;
  const withoutSpaces = value.trim().replace(/s+/g, '_');

  const caps = withoutSpaces.match(regex);
  const splits = withoutSpaces.split(regex);

  let finalString = splits.shift();

  for (let i = 0; i < splits.length; i++) {
    finalString += `${caps[i]}_${splits[i]}_`;
  }

  return finalString
    .toLowerCase()
    .replace(/_+/g, '_')
    .replace(/^_?(.+?)_?$/, '$1');
}

```

La funci√≥n anterior intenta imitar el `snakeCase()`m√©todo de la biblioteca *Lodash* JavaScript. Aqu√≠, tenemos que usar el cuerpo de la funci√≥n tradicional envuelto en llaves ( `{}`) ya que tenemos muchas declaraciones de JavaScript dentro del cuerpo de la funci√≥n.

> A diferencia de las funciones regulares, el `arguments`objeto no existe para las funciones de flecha. Sin embargo, pueden tener acceso al `arguments`objeto de una funci√≥n principal sin flecha.

```
function fetchLastScore() {
  return () => {
    console.log(arguments[arguments.length - 1]);
  }
}

fetchLastScore(42, 68, 49, 83, 72)(); // 72

```

### **Expresiones de funci√≥n invocadas inmediatamente (IIFE)**

Una aplicaci√≥n √∫til de funciones en JavaScript se observa en *Expresiones de funciones invocadas inmediatamente (IIFE)* , que son ***funciones que se definen y se llaman inmediatamente sin guardar una referencia a la funci√≥n\*** . Este tipo de aplicaci√≥n de funciones generalmente se ve en scripts de inicializaci√≥n √∫nicos, bibliotecas de JavaScript que exponen una interfaz p√∫blica modular como *jQuery* , etc.

Usando funciones regulares de JavaScript, los IIFE generalmente toman una de estas formas:

```
// FIRST FORM:
// Wrap the function expression in parentheses
// The invocation expression comes afterwards

(function(a, b) {
  // ...function body here
})(arg1, arg2);

// SECOND FORM:
// Wrap the function expression together with
// the invocation expression in parentheses

(function(a, b) {
  // ...function body here
}(arg1, arg2));

```

La sintaxis de la funci√≥n de flecha tambi√©n se puede usar con IIFE siempre que la funci√≥n de flecha est√© entre par√©ntesis.

```
// IIFE: With Arrow Function
// The arrow function is called immediately with a list of arguments
// and the return value is assigned to the `compute` variable

const compute = ((...numbers) => {

  // Private members

  const length = numbers.length;
  const min = Math.min(...numbers);
  const max = Math.max(...numbers);

  const sum = numbers.reduce((a, b) => a + Number(b), 0);

  // Expose an inteface of public methods

  return {
    sum: () => sum,
    avg: () => sum / length,
    range: () => max - min
  };

})(42, 68, 49, 83, 72, 65, 77, 74, 86, 51, 69, 47, 53, 58, 51);

// Access the exposed public methods

console.log(compute.sum()); // 945
console.log(compute.avg()); // 63
console.log(compute.range()); // 44

```

### **Funciones de devoluci√≥n de llamada**

Funciones de devoluci√≥n de llamada se utilizan en gran medida en los programas as√≠ncronos y tambi√©n en m√©todos de arreglos como `map()`, `filter()`, `forEach()`, `reduce()`, `sort()`, `find()`, `findIndex()`, etc.

> Las funciones de flecha son perfectas para usar como funciones de devoluci√≥n de llamada.

En un fragmento de c√≥digo anterior, vimos c√≥mo se usaba una funci√≥n de flecha `reduce()`para calcular la suma de una matriz de n√∫meros. Usar la funci√≥n de flecha es m√°s compacto y ordenado. De nuevo, aqu√≠ est√° la comparaci√≥n:

```
// WITHOUT ARROW FUNCTION
const sum = numbers.reduce(function(a, b) {
  return a + Number(b);
}, 0);

// WITH ARROW FUNCTION
const sum = numbers.reduce((a, b) => a + Number(b), 0);

```

Hagamos algo un poco m√°s complicado para demostrar c√≥mo usar las funciones de flecha como devoluciones de llamada de matriz puede ayudarnos a lograr m√°s con menos c√≥digo. *Imitaremos* el `flattenDeep()`m√©todo de la biblioteca *Lodash* JavaScript. Este m√©todo aplana recursivamente una matriz. Sin embargo, en nuestra implementaci√≥n, aplanaremos recursivamente la matriz de argumentos pasados a la funci√≥n.

Aqu√≠ est√° el fragmento de c√≥digo para la `flattenDeep()`funci√≥n:

```
const flattenDeep = (...args) => args.reduce(
  (a, b) => [].concat(a, Array.isArray(b) ? flattenDeep(...b) : b)
);

```

As√≠ de geniales pueden ser las funciones de flecha cuando se usan como funciones de devoluci√≥n de llamada, especialmente cuando se trabaja con m√©todos de matriz que toman funciones de devoluci√≥n de llamada.

### **This y funciones de flecha**

Una fuente importante de confusi√≥n y errores en muchos programas JavaScript es la resoluci√≥n de valor de `this`.

> `this` resuelve diferentes valores seg√∫n el alcance y el contexto de una invocaci√≥n de funci√≥n.

Por ejemplo, cuando se invoca una funci√≥n con la `new`palabra clave, `this`apunta a la instancia creada por el constructor, sin embargo, cuando se llama a la misma funci√≥n sin la `new`palabra clave, `this`apunta al objeto global (en modo *no estricto* ) que en el entorno del navegador es el `window`objeto

Aqu√≠ hay una ilustraci√≥n simple. En el siguiente fragmento de c√≥digo, llamar `Person()`sin la `new`palabra clave crear√° accidentalmente una variable global llamada `name`porque la funci√≥n est√° en modo *no estricto* .

```
function Person(name) {
  this.name = name;
}

var person = Person('Glad Chinda');

console.log(person); // undefined
console.log(name); // "Glad Chinda"
console.log(window.name); // "Glad Chinda"

```

Otra fuente com√∫n de confusi√≥n con los `this`oyentes de eventos DOM es.

> En los oyentes de eventos, `this`apunta al elemento DOM al que se dirige el evento.

Considere el siguiente fragmento de c√≥digo:

```
function ScrollController(offset) {
  this.offsets = { offsetY: offset };
}

ScrollController.prototype.registerScrollHandler = function() {
  window.addEventListener('scroll', function(event) {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }, false);
}

var controller = new ScrollController(100);
controller.registerScrollHandler();

```

Todo se ve bien con este fragmento de c√≥digo. Sin embargo, cuando comience a desplazarse verticalmente por la ventana del navegador, ver√° que se registra un error en la consola. El motivo del error es que `this.offsets`es `undefined`y que est√°n tratando de acceder a la `offsetY`propiedad de `undefined`.

La pregunta es: **¬øc√≥mo es posible que** `**this.offsets**` **sea as√≠** `**undefined**`**?**

Se debe a que el valor `this`dentro del detector de eventos es diferente del valor `this`dentro de la funci√≥n prototipo que lo encierra. `this`dentro del detector de eventos se√±ala `window`cu√°l es el destino del evento y `offsets`no existe como una propiedad en `window`. Por lo tanto, `this.offsets`dentro del evento est√° el oyente `undefined`.

`Function.prototype.bind()`se puede usar para establecer expl√≠citamente el `this`enlace para una funci√≥n. Aqu√≠ se explica c√≥mo se puede corregir el error configurando expl√≠citamente el `this`enlace usando `Function.prototype.bind()`:

```
// Using .bind() on event listener to resolve the value of `this`

ScrollController.prototype.registerScrollHandler = function() {
  this.element.addEventListener('scroll', (function(event) {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }).bind(this), false);
}

```

Aqu√≠, envolvimos el detector de eventos con par√©ntesis y llamamos al `bind()`m√©todo que pasa el valor de `this`la funci√≥n prototipo adjunta. Llamar `bind()`realmente devuelve una nueva funci√≥n con el `this`enlace especificado . Todo funciona perfectamente ahora sin ning√∫n error.

> Con las funciones de flecha ES6, no hay `this`enlace. Por lo tanto, las funciones de flecha utilizan el valor de `this`su ancestro de funci√≥n no de flecha m√°s cercano.

En un caso como el nuestro, en lugar de usar el `bind()`que realmente devuelve una nueva funci√≥n, podemos usar una funci√≥n de flecha en su lugar, ya `this`que se retiene el enlace de la funci√≥n prototipo envolvente.

Aqu√≠ est√°:

```
// Using arrow function for event listener

ScrollController.prototype.registerScrollHandler = function() {
  this.element.addEventListener('scroll', event => {
    if (window.scrollY === this.offsets.offsetY) {
      console.log(`${this.offsets.offsetY}px`);
    }
  }, false);
}

```

## **4. Desestructuraci√≥n**

La desestructuraci√≥n es otra mejora muy importante para la sintaxis de JavaScript. *La desestructuraci√≥n* permite acceder y asignar valores a variables locales desde estructuras complejas como matrices y objetos, sin importar cu√°n profundamente anidados est√©n esos valores en la matriz u objeto principal. Hay dos formas de desestructuraci√≥n: la **desestructuraci√≥n de objetos** y la **desestructuraci√≥n de matrices** .

#### Desestructuraci√≥n de objetos

Para ilustrar la desestructuraci√≥n de objetos, digamos que tenemos un objeto de pa√≠s que se parece a lo siguiente:

```
const country = {
  name: 'Nigeria',
  region: 'Africa',
  codes: {
    cca2: 'NG',
    dialcode: '+234'
  },
  cities: [
    'Lagos',
    'Abuja',
    'Port Harcourt',
    'Benin',
    'Ibadan',
    'Calabar',
    'Warri'
  ]
}

```

Queremos mostrar alguna informaci√≥n sobre este pa√≠s a nuestros visitantes. El siguiente fragmento de c√≥digo muestra una `countryInfo()`funci√≥n muy b√°sica que hace exactamente eso:

```
function countryInfo(country) {
  const name = country.name;
  const region = country.region || 'the world';
  const code2 = country.codes.cca2;
  const dialcode = country.codes.dialcode;
  const cities = country.cities;

  return (
`
COUNTRY TIPS:

${name}(${code2}) is one of the largest countries in ${region}.
There are so many important cities you can visit in ${name}
and here are some of them:

${cities.slice(0, 3).join(', ')} and ${cities.slice(3).length} others.

Phone numbers in ${name} usually begin with ${dialcode}.
`
  ).trim();
}

console.log(countryInfo(country));

// COUNTRY TIPS:
//
// Nigeria(NG) is one of the largest countries in Africa.
// There are so many important cities you can visit in Nigeria
// and here are some of them:
//
// Lagos, Abuja, Port Harcourt and 4 others.
//
// Phone numbers in Nigeria usually begin with +234.

```

En este fragmento, hemos podido extraer algunos valores del objeto pa√≠s y asignarlos a variables locales en la `countryInfo()`funci√≥n, lo que funcion√≥ muy bien.

Con la desestructuraci√≥n de ES6, podemos extraer estos valores y asignarlos a variables con una sintaxis m√°s elegante, m√°s limpia y m√°s corta. Aqu√≠ hay una comparaci√≥n entre el fragmento antiguo y la desestructuraci√≥n de ES6:

```
// OLD METHOD
const name = country.name;
const region = country.region || 'the world';
const code2 = country.codes.cca2;
const dialcode = country.codes.dialcode;
const cities = country.cities;

// ES6 DESTRUCTURING
const {
  name,
  region = 'the world',
  codes: { cca2: code2, dialcode },
  cities
} = country;

```

Esta forma de desestructuraci√≥n en el fragmento de c√≥digo anterior se conoce como *desestructuraci√≥n de objetos* , porque estamos extrayendo valores de un objeto y asign√°ndolos a variables locales.

> Para la desestructuraci√≥n de objetos, se utiliza un literal de objeto en el lado izquierdo de una expresi√≥n de asignaci√≥n.

Incluso puede usar la desestructuraci√≥n de objetos con par√°metros de funci√≥n como se muestra en el siguiente fragmento:

```
const person = {
  name: 'Glad Chinda',
  birthday: 'August 15'
}

// FUNCTION WITHOUT DESTRUCTURED PARAMETERS
function aboutPerson(person = {}) {
  const { name, birthday, age = 'just a few' } = person;

  console.log(`My name is ${name} and I'm ${age} years old. I celebrate my birthday on ${birthday} every year.`);
}

// FUNCTION WITH DESTRUCTURED PARAMETERS
function aboutPerson({ name, birthday, age = 'just a few' } = {}) {
  console.log(`My name is ${name} and I'm ${age} years old. I celebrate my birthday on ${birthday} every year.`);
}

aboutPerson(person);

// My name is Glad Chinda and I'm just a few years old. I celebrate my birthday on August 15 every year.

```

### Desestructuraci√≥n de matrices

La desestructuraci√≥n de matrices se utiliza para extraer valores de matrices y asignarlos a variables locales. Digamos que tenemos los valores RGB (Rojo-Verde-Azul) de un color representado como una matriz de la siguiente manera:

```
const color = [240, 80, 124];

```

Queremos mostrar los valores RGB para el color dado. As√≠ es como se puede hacer con la desestructuraci√≥n de matrices.

```
// Array Destructuring
const [red, green, blue] = color;

console.log(`R: ${red}, G: ${green}, B: ${blue}`);
// R: 240, G: 80, B: 124

```

> Para la desestructuraci√≥n de matrices, se usa un literal de matriz en el lado izquierdo de una expresi√≥n de asignaci√≥n.

Con la desestructuraci√≥n de la matriz, es posible omitir la asignaci√≥n de valores que no necesita. Digamos que queremos solo el valor azul del color. Aqu√≠ es c√≥mo podemos omitir los valores rojo y verde sin asignarlos a variables locales.

```
const [,, blue] = color;

console.log(`B: ${blue}`);
// B: 124

```

La desestructuraci√≥n de matrices tambi√©n se puede usar con par√°metros de funci√≥n de manera muy similar a la desestructuraci√≥n de objetos. Sin embargo, hay otras formas en que la desestructuraci√≥n de matrices se puede utilizar para resolver problemas comunes.

Un caso de uso muy importante es el **intercambio de variables** . Digamos que queremos buscar en una base de datos los registros almacenados entre dos fechas. Podr√≠amos escribir una funci√≥n simple que acepte dos `Date`objetos: `fromDate`y de la `toDate`siguiente manera:

```
function fetchDatabaseRecords(fromDate, toDate) {
// ...execute database query
}

```

Queremos asegurarnos de que `fromDate`siempre sea antes `toDate`‚Ää; por lo tanto, simplemente queremos cambiar las fechas en los casos `fromDate`posteriores `toDate`. As√≠ es como podemos cambiar las fechas usando la desestructuraci√≥n de matrices:

```
function fetchDatabaseRecords(fromDate, toDate) {
  if (fromDate > toDate) {
    // swap the dates using array destructuring
    [fromDate, toDate] = [toDate, fromDate];
  }

  // ...execute database query
}
```

> Para obtener una gu√≠a m√°s detallada sobre la desestructuraci√≥n, puede consultar [ES6 Destructuring: The Complete Guide](https://codeburst.io/es6-destructuring-the-complete-guide-7f842d08b98f?ref=morioh.com) .

------

## **5. Clases**

Las clases son una caracter√≠stica que algunos desarrolladores de JavaScript siempre han deseado durante mucho tiempo, especialmente aquellas que ten√≠an experiencia previa con otros lenguajes de programaci√≥n orientados a objetos. Las mejoras de sintaxis de JavaScript ES6 finalmente incluyeron clases.

Aunque las clases ahora son parte de JavaScript, no se comportan exactamente de la misma manera que en otros lenguajes de programaci√≥n cl√°sicos. Se parecen m√°s al az√∫car sint√°ctico que a los m√©todos anteriores de simulaci√≥n del comportamiento basado en la clase. Por lo tanto, todav√≠a funcionan seg√∫n el modelo de herencia protot√≠pica de JavaScript.

Antes de ES6, las clases se simulaban utilizando *funciones de constructor* y los m√©todos de instancia se creaban b√°sicamente mejorando el prototipo de la funci√≥n de constructor. Por lo tanto, cuando se llama a la funci√≥n constructora con la `new`palabra clave, devuelve una instancia del tipo constructor que tiene acceso a todos los m√©todos de su prototipo. El valor de los `this`puntos a la instancia del constructor.

Aqu√≠ hay un ejemplo:

`````
// The Rectangle constructor
function Rectangle(length, breadth) {
  this.length = length || 10;
  this.breadth = breadth || 10;
}

// An instance method
Rectangle.prototype.computeArea = function() {
  return this.length * this.breadth;
}

// Create an instance using the new keyword
var rectangle = new Rectangle(50, 20);

console.log(rectangle.computeArea()); // 1000

// rectangle is also an instance of Object
// Due to JavaScript's prototypal inheritance
console.log(rectangle instanceof Rectangle); // true
console.log(rectangle instanceof Object); // true
`````
### **Sintaxis de clase**

Las clases son similares a las funciones de muchas maneras. Al igual que con las funciones, las clases se pueden definir usando *declaraciones de* *clase* y *expresiones de clase* usando la `class`palabra clave.

> Al igual que con las funciones, las clases son ciudadanos de primera mano y se pueden transmitir como valores alrededor de su programa.

**Sin embargo, hay un par de diferencias significativas entre clases y funciones.**

1. Las declaraciones de clase no se izan y se comportan como `let`declaraciones.
2. Los constructores de clases siempre deben llamarse con, `new`mientras que los m√©todos de clase no pueden llamarse con `new`.
3. El c√≥digo de definici√≥n de clase siempre est√° en *modo estricto* .
4. Todos los m√©todos de clase no son enumerables.
5. Un nombre de clase no se puede modificar desde dentro de la clase.

Aqu√≠ est√° nuestro `Rectangle`tipo anterior reescrito usando la sintaxis de clase:

```
class Rectangle {
  // The class constructor
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }

  // An instance method
  computeArea() {
    return this.length * this.breadth;
  }
}

// Create an instance using the new keyword
const rectangle = new Rectangle(50, 20);

console.log(rectangle.computeArea()); // 1000

// rectangle is also an instance of Object
// Due to JavaScript's prototypal inheritance
console.log(rectangle instanceof Rectangle); // true
console.log(rectangle instanceof Object); // true

console.log(typeof Rectangle); // function
console.log(typeof Rectangle.prototype.computeArea); // function
```

Aqu√≠, usamos un `constructor()`m√©todo especial para definir la l√≥gica del constructor de clases y tambi√©n establecer todas las propiedades de la instancia. De hecho, cada vez que el `typeof`operador se usa en una clase, devuelve `‚Äúfunction‚Äù`‚Ää, ya sea que un constructor est√© expl√≠citamente definido para la clase o no.

Observe tambi√©n que el `computeArea()`m√©todo de instancia se agrega realmente al objeto prototipo de la funci√≥n de constructor de clase subyacente. Esa es la raz√≥n por la que tambi√©n se usa el `typeof`operador en los `Rectangle.prototype.computeArea`retornos `‚Äúfunction‚Äù`.

En base a estas similitudes, puede concluir que la sintaxis de la clase es principalmente az√∫car sint√°ctica adem√°s de los m√©todos anteriores para crear tipos personalizados.

Veamos otro ejemplo que es un poco m√°s complicado para demostrar el uso de expresiones de clase y pasar clases como argumentos a funciones.

```
// An anonymous class expression
// assigned to a variable
const Rectangle = class {

  // The class constructor
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }

  // An instance method
  computeArea() {
    return this.length * this.breadth;
  }

}

// A class passed as argument to a function
// Notice how the class is instantiated with new
const computeArea = (Shape, ...dimensions) => {
  return (new Shape(...dimensions)).computeArea();
}

console.log(computeArea(Rectangle, 50, 20)); // 1000
```

Aqu√≠, primero creamos una expresi√≥n de clase an√≥nima y la asignamos a la `Rectangle`variable. A continuaci√≥n, creamos una funci√≥n que acepta una `Shape`clase como primer argumento y las dimensiones para crear instancias `Shape`como los argumentos restantes. El fragmento de c√≥digo supone que cualquier `Shape`clase que reciba implementa el `computeArea()`m√©todo.

### **Clases Extendidas**

Al igual que con otros lenguajes de programaci√≥n orientados a objetos, las clases de JavaScript tienen funcionalidades para extensiones de clase. Por lo tanto, es posible crear clases *derivadas* o *secundarias* con funcionalidad modificada a partir de una clase *primaria* .

Digamos que tenemos una `Rectangle`clase para crear rect√°ngulos y queremos crear una `Square`clase para crear rect√°ngulos con igual longitud y amplitud (cuadrados). As√≠ es como podemos hacerlo:

```
class Rectangle {
  constructor(length, breadth) {
    this.length = length || 10;
    this.breadth = breadth || 10;
  }

  computeArea() {
    return this.length * this.breadth;
  }
}

// The Square class extends the Rectangle class
class Square extends Rectangle {

  constructor(length) {
    // super() calls the constructor of the parent class
    super(length, length);
  }

}

const square = new Square;

// Square inherits the methods and properties of Rectangle
console.log(square.length); // 10
console.log(square.breadth); // 10
console.log(square.computeArea()); // 100

// square is also an instance of Rectangle
console.log(square instanceof Square); // true
console.log(square instanceof Rectangle); // true
```

Primero, observe el uso de la `extends`palabra clave, que indica que queremos crear una clase derivada de una clase primaria.

> La clase derivada hereda todas las propiedades y m√©todos en el prototipo de la clase padre, incluido el constructor.

Observe tambi√©n que usamos una `super`referencia para invocar al constructor de la clase padre desde dentro del constructor de la clase derivada. Esto es muy √∫til cuando desea mejorar la funcionalidad de un m√©todo heredado en la clase derivada.

Por ejemplo, una llamada a `super.computeArea()`desde dentro de la `Square`clase llamar√° al `computeArea()`m√©todo implementado en la `Rectangle`clase.

> Se `super()`debe hacer una llamada a en el constructor de cada clase derivada y debe venir antes de que se haga referencia a ella `this`.

Esto se debe a que llamar `super()`establece el valor de `this`. Sin embargo, `super()`nunca debe usarse en una clase que no sea una clase derivada, ya que se considera un error de sintaxis.

Crear clases derivadas no se limita a extender las clases solo. Las clases derivadas generalmente se crean al extender cualquier expresi√≥n de JavaScript que se pueda usar como constructor y tambi√©n tenga un prototipo, como las funciones de JavaScript. Por lo tanto, lo siguiente es posible:

```
function Person(name) {
  this.name = name || 'Glad Chinda';
}

Person.prototype.getGender = function() {
  return this.gender;
}

class Male extends Person {
  constructor(name) {
    super(name);
    this.gender = 'MALE';
  }
}

const me = new Male;

// Male inherits the methods and properties of Person
console.log(me.getGender()); // "MALE"

// me is also an instance of Person
console.log(me instanceof Male); // true
console.log(me instanceof Person); // true
```

### **Miembros de clases est√°ticas**

Hasta ahora hemos estado buscando *m√©todos de instancia* y *propiedades* . Hay momentos en los que necesita *m√©todos* o *propiedades* *est√°ticos* que se aplican directamente a la clase y no cambian de una instancia a otra. Antes de ES6, los miembros est√°ticos se pueden agregar de la siguiente manera:

```
function Lion () { 
  // constructor function 
} 

// Propiedad est√°tica 
Lion.category = 'ANIMAL'; 

// M√©todo est√°tico 
Lion.animalType = function () { 
  return 'CAT'; 
} 

console.log (Lion.category); // "ANIMAL" 
console.log (Lion.animalType ()); // "GATO"
```

Con las clases ES6, la `static` palabra clave se coloca antes del nombre de un m√©todo para indicar que el m√©todo es un *m√©todo est√°tico* . Sin embargo,  no se pueden crear *propiedades est√°ticas* desde dentro de la clase. As√≠ es como podemos crear miembros est√°ticos:

```
class Lion { 
  // M√©todo 
  est√°tico static animalType () { 
    return 'CAT'; 
  } 
} 

// Propiedad est√°tica 
Lion.category = 'ANIMAL'; 

console.log (Lion.category); // "ANIMAL" 
console.log (Lion.animalType ()); // "GATO"
```

> Los miembros de clase est√°tica tambi√©n son heredados por las clases derivadas. Pueden ser anulados por la clase derivada de la misma manera que los m√©todos y propiedades de instancia.

Aqu√≠ hay un ejemplo simple:

```
class Lion { 
  // M√©todo 
  est√°tico static animalType () { 
    return 'CAT'; 
  } 
} 

// Propiedad est√°tica 
Lion.category = 'ANIMAL'; 

// Clase de 
clase Leona derivada Leona extiende Le√≥n { 

  // Anular m√©todo 
  est√°tico static animalType () { 
    return `$ {super.animalType ()} :: LION`; 
  } 

} 

console.log (Lioness.category); // "ANIMAL" 
console.log (Lioness.animalType ()); // "GATO :: LE√ìN"
```

## **M√°s caracter√≠sticas de Javascript 6**

Hay un par de caracter√≠sticas de clase m√°s que vale la pena considerar, una de las cuales son las ***propiedades de acceso\*** . Pueden ser muy √∫tiles en casos donde necesita tener propiedades en el prototipo de clase.

Aqu√≠ hay un ejemplo simple:

```
clase Persona { 
  constructor (nombre, apellido) { 
    this.firstname = nombre || 'Alegre'; 
    this.lastname = apellido || 'Chinda'; 
  } 

  get fullname () { 
    return `$ {this.firstname} $ {this.lastname}`; 
  } 

  set fullname (value) { 
    const [nombre, apellido] = value.split (''); 
    if (nombre) this.firstname = nombre; 
    if (apellido) this.lastname = apellido; 
  } 
} 

const me = nueva persona; 
console.log (me.fullname); // "Glad Chinda" 

me.fullname = "Jamie"; 
console.log (me.fullname); // "Jamie Chinda" 

me.fullname = "John Doe (Junior)"; 
console.log (yo. nombre completo); // "John Doe"
```

Otra buena caracter√≠stica de las clases que es muy similar a los literales de objetos es la capacidad de usar ***nombres calculados\*** para los miembros de la clase. Estos nombres calculados tambi√©n se pueden usar para propiedades de acceso.

> Los nombres computados son generalmente expresiones JavaScript envueltas entre un par de *corchetes* ([]).

Aqu√≠ hay un ejemplo simple:

```
prefijo const = 'calcular'; 

class Square { 
  constructor (length) { 
    this.length = length || 10; 
  } 

  // Un m√©todo de clase calculada 
  [`$ {prefijo} $ {Square.prototype.constructor.name} Area`] () { 
    return this.length * this.length; 
  } 
} 

const square = nuevo cuadrado; 
console.log (square.computeSquareArea ()); // 100
```

### Conclusi√≥n

Aunque este ha sido un art√≠culo bastante largo para seguir, creo firmemente que la mayor√≠a de nosotros debe haber aprendido algunas maneras en que podemos mejorar nuestro c√≥digo usando algunas nuevas funciones de JavaScript ES6.

> üî• Seguro tambi√©n te interesa: [C√≥mo aprender Python en 2020](/python/), [ü•á ‚ñ∑ C√≥mo aprender aprendizaje autom√°tico o machine learning en 2020 ü§ñ](/que-aprender-sobre-machine-learning-2020/), [‚ñ∑ M√°s de 200 de los mejores tutoriales de aprendizaje autom√°tico, PNL y Python](/aprendizaje-automatico-cursos-ingles/)
{: .notice--danger}

### **Relacionados** <!-- omit in toc -->

[‚ñ∑ C√≥mo Aprender Javascript en 2020 üë®‚ÄçüöÄ](/javascript/)

[‚ñ∑ Los Mejores Recursos para Aprender Javascript üë®‚ÄçüöÄ](/javascript-recursos/)

[‚ñ∑ An√°lisis y Memoria 2020: Los mejores proyectos de Javascript üë®‚Äçüíª](/memoria-mejores-proyectos-javascript/)

[üî• ‚ñ∑ Rome, ¬øLa Mejor Herramienta para Javascript jam√°s creada?](/roma-herramienta-javascript/)

[‚ñ∑ Editores de Texto](/categoria/#editor-de-texto)
  * [Eclipse Theia](/wiki/eclipse-theia)
  * 
[ü•á ‚ñ∑ C√≥mo APRENDER a Programar GRATIS cualquier Lenguaje de Programaci√≥n en 2020](/programar/)

[‚ñ∑ Las 15 Mejores Lenguajes de Programaci√≥n para Aprender en 2020](/15-mejores-lenguajes-programacion/)

[‚ñ∑ Deep Java Library: nuevo kit de herramientas de aprendizaje profundo para desarrolladores de Java üë®‚Äçüíª](/deep-java-libreria-herramienta-desarrolladores-aprendizaje-profundo/)

<div class="fb-post" data-href="https://www.facebook.com/ciberninjas/posts/1331109157075936" data-width="850" data-show-text="true"><blockquote cite="https://developers.facebook.com/ciberninjas/posts/1331109157075936" class="fb-xfbml-parse-ignore"><p>üë®‚Äçüíª Los mejores libros con los que aprender a programar en Java y con Android, en Espa√±ol</p>Publicada por <a href="https://www.facebook.com/ciberninjas/">Ciberninjas</a> en&nbsp;<a href="https://developers.facebook.com/ciberninjas/posts/1331109157075936">Martes, 3 de marzo de 2020</a></blockquote></div>
